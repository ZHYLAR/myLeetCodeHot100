// 思路：
//  1. 遍历每个柱子，以当前柱子的高度为高度，计算以当前柱子为高的矩形的最大面积。
//  2. 为了计算以当前柱子为高的矩形的最大面积，需要知道当前柱子左边最后一个比他大的元素，以及右边最后一个比他大的元素。
//   也就是要知道左边第一个比他小的元素，以及右边第一个比他小的元素
//  3. 左右边界的确定可以使用单调栈来实现。栈维护一个单调递增的柱体高度索引序列，
//   遍历到比栈顶元素低时，以栈顶柱子为高时，栈pop后，栈顶元素就是左边第一个比他小的元素的索引。
//   当前遍历元素就是当前柱子右边第一个比他小的元素的索引。

class Solution
{
public:
    int largestRectangleArea(vector<int> &heights)
    {
        int n = heights.size();
        stack<int> stk;
        int res = 0;

        // 最后位置补 0 以处理最后一个元素。
        heights.push_back(0);
        // 这个地方多一个 0，所以遍历到 n
        for (int right = 0; right <= n; right++)
        {
            // 只计算以栈顶元素的高度为高度的矩形大小，也即只统计栈顶元素的左右边界。
            // 进栈前弹出的都是左边比当前遍历元素大的→确定左边界；
            // 出栈时必定是右边第一次遇到比当前遍历元素小的→确定右边界
            while (!stk.empty() && heights[stk.top()] >= heights[right])
            {
                // 如果当前遍历元素小于栈顶元素，说明当前遍历元素是栈顶元素的右边界
                // 弹出栈顶元素并处理
                int h = heights[stk.top()]; // 以栈顶元素的高度为高
                stk.pop();
                // 由于是单调栈，弹出后，此时的栈顶元素即为左边界。
                // 如果栈为空，说明当前遍历元素是最小的，计算时宽度应该为 1，左边界设置为-1。
                int left = (stk.empty()) ? -1 : stk.top();
                res = max(res, (right - left - 1) * h);
            }
            // 当前元素 right 入栈前，
            // 栈顶所有高度大于等于当前柱体高度的元素都被弹出，从而保持栈的单调性
            // 所以先 while 再 push
            stk.push(right);
        }

        return res;
    }
};